---
title: "브라우저 렌더링 프로세스"
titleStyle:
  - text: "브라우저 렌더링"
    isBold: true
  - text: " 프로세스"
    isBold: false
description: "브라우저에서 렌더링 되는 과정에 대해 알아봤어요."
category: "frontend"
tags: ["browser"]
publishedAt: "2024년 10월 2일"
updatedAt: "2024년 10월 2일"
isPublished: true
---

## 여는 글

사용자는 당연하게도 로딩이 빠르고 상호작용이 원활한 웹 경험을 원해요.

그렇기 때문에 브라우저에서의 렌더링 과정을 이해하고 최적화를 위해 고민하는 것은 프론트엔드에서 중요한 영역이고,  
그렇기 때문에 프론트엔드 면접에서 자주 등장하는 주제이기도 해요.

이전에 브라우저에서 발생하는 렌더링 과정에 대해 자세히 알아보기 위해 정리해뒀던 내용을 다시 보면서 정리해보았어요.

### 싱글 스레드

현재 거의 모든 웹에서 동적인 인터랙션을 위해 자바스크립트 사용이 필수가 되었어요.  
하지만 자바스크립트는 **싱글 스레드** 언어로 설계되었기 때문에, 무거운 연산 혹은 실행시간이 긴 작업인 경우 이후의 작업이 블로킹 될 수 있어요.

> [!note] 싱글 스레드(single thread)
> 여러 작업이 동시에 일어나 하나의 DOM(Document Object Model)을 조작하게 되는 경우의 동시성 문제를 해결하기 위한 방식이에요. 한 번에 하나의 작업만을 수행하기 때문에 예측가능하고 일관된 실행 순서를 가져 경쟁 상태(race condition)를 방지하고 디버깅을 쉽게 해줘요.

웹페이지를 표시하기 위해 브라우저에서 어떤 과정을 거치게 되는지 알아볼게요.

## 브라우저의 렌더링 과정

<p> </p>

### 1. 사용자의 URL 입력

사용자가 `https://example.com` 을 입력하게 되면 브라우저는 `DNS(Domain Name System)` 서버에 입력한 `URL`의 조회를 요청하고 응답으로 `IP 주소`를 받게 돼요.

### 2. 브라우저의 데이터 요청

브라우저는 응답받은 `IP` 주소를 통해 서버에 연결을 시도하는데, 이때 `HTTP`, `HTTPS` 요청은 `TCP 연결` 위에서 전송돼요.
이 과정을 `3-way handshake`, 세 방향 핸드셰이크라고 부르고 다음과 같아요.

1. 브라우저(클라이언트)가 서버에 연결 요청을 보내요. (`SYN`: Synchronize)
2. 서버가 브라우저의 요청을 받았음을 알리고, 연결할 준비가 되었다고 응답해요. (`SYN-ACK`: synchronize-Acknowledge)
3. 브라우저가 서버의 응답을 확인하고 연결되었다고 다시 서버에게 알려요. (`ACK`: Acknowledge)

<MDXImage
  src="posts/browser-rendering/tcp.png"
  width="350px"
  alt="TCP 연결 과정"
  caption="TCP 연결 과정"
/>

이렇게 `TCP 연결`이 설정 되면 브라우저와 서버간 데이터를 전송할 수 있어요.  
이제 브라우저는 화면에 보여줄 데이터(`HTML`, `CSS`, `JavaScript` 등)를 가져오기 위한 요청을 보내면, 서버에서 전송한 리소스를 응답받게 돼요.

### 3. 브라우저의 데이터 파싱

브라우저는 응답받은 데이터 중 `HTML`은 `DOM`으로 변환하고, `CSS`는 `CSSOM`으로 파싱하게 돼요.  
먼저 `HTML`를 `DOM` 트리로 만드는 파싱 과정을 이미지와 함께 살펴볼게요.

<MDXImage
  src="posts/browser-rendering/dom-parsing.png"
  alt="DOM 파싱 과정"
  caption="DOM 파싱 과정"
/>

1. 전달받은 바이트 기반의 `HTML`을 지정된 파일 인코딩(`UTF-8` 등)에 따라 개별 문자(Character)로 변환해요.
2. 변환된 문자는 토큰화를 통해 `HTML` 문법에 따라 토큰으로 나뉘고,
3. 토큰들을 노드 객체로 만들어요.
4. 만들어진 노드들을 부모-자식 관계로 연결해 트리 구조가 만들어지게 돼요.

이렇게 `HTML`을 `DOM` 트리로 파싱할 수 있게 돼요.

`DOM`을 파싱하는 도중 과정에서 `<link rel="stylesheet">` 같은 `CSS` 리소스를 만나면, 해당 파일을 별도로 요청하고 `CSSOM` 트리로 파싱하게 돼요.

<MDXImage
  src="posts/browser-rendering/cssom-parsing.png"
  alt="CSSOM 파싱 과정"
  caption="CSSOM 파싱 과정"
/>

`DOM`과 마찬가지로

1. 바이트를 각각의 개별 문자로 변환하고,
2. 문자를 토큰화해 나누고,
3. 노드 객체로 만든 뒤,
4. 트리 구조의 형태로 만들게 돼요.

스타일은 상위 요소에서 하위 요소로 전파되기 때문에, 브라우저는 상위 노드부터 하위 노드로 재귀적으로 스타일을 적용하게 돼요.

### 4. 렌더 트리 결합

이제 만들어진 `DOM` 트리와 `CSSOM` 트리를 하나의 렌더 트리로 결합하는 과정이 진행돼요.

<MDXImage
  src="posts/browser-rendering/render-tree.png"
  alt="렌더 트리 결합 과정"
  caption="렌더 트리 결합 과정"
/>

페이지에 표시되는 모든 `DOM`과 `CSSOM`의 스타일 정보를 캡쳐하게 되는데,  
렌더링에 반영하지 않는 노드와 CSS를 통해 숨겨진 노드(`display: none` 등)는 렌더 트리에서 누락시켜요.

각 `DOM` 노드에 대한 `CSSOM` 노드의 스타일 규칙을 계산하고 적용한 뒤 해당 노드를 렌더 트리에 등록해요.
이렇게 모든 노드를 렌더 트리에 등록하게 되면 화면에 출력하기 위한 과정에 들어가요.

### 5. 리플로우, 페인트

렌더 트리가 준비되면 먼저 레이아웃을 설정하는 리플로우 단계를 진행해요.  
브라우저는 렌더 트리를 순회하며 표시할 화면에서 노드의 정확한 위치와 크기를 계산하는 과정을 거치게 돼요.

이제 계산된 노드를 실제 화면에 픽셀로 변환하는 페인트 단계를 진행하게 돼요.

만약 첫 렌더링 이후 레이아웃(`transform`, `position` 등)이 변경되었다면 리플로우 과정이 먼저 진행되고,  
레이아웃이 변경되지 않는 변경이라면 화면만 다시 그리는 리페인트 과정만 이뤄지게 돼요.

리소스를 받아온 이후의 단계를 요약하면 다음과 같아요.

1. `HTML`을 파싱해 `DOM` 트리를 빌드
2. `CSS`를 파싱해 `CSSOM` 트리를 빌드
3. `DOM`, `CSSOM` 트리를 렌더 트리로 결합
4. 렌더 트리에서 리플로우 단계를 통해 각 노드의 크기 및 위치를 계산
5. 페인트(리페인트) 단계를 통해 각 노드를 화면에 픽셀로 렌더링

만약 `DOM` 또는 `CSSOM`이 수정된 경우 화면에서 다시 렌더링 해야 할 노드를 알아내기 위해 이 프로세스를 반복하게 돼요.
따라서 렌더링 과정을 최적화 하기 위해서는 이러한 단계를 줄일 필요가 있어요.

> [!note] React에서의 리플로우, 리페인트
> React에서는 변경된 내용을 Virtual DOM에서 감지해, Diffing algorithm을 통해 실제 `DOM`과 비교해 변경된 부분만 갱신해요. 이를 통해 불필요한 리플로우, 리페인트를 줄일 수 있어 성능상의 이점이 있어요.

## 닫는 글

이전에 썼던 글을 다시 회고하면서, 실제로 이러한 과정을 고려해서 코드를 작성하고 있었나.. 하며 다시 되돌아보는 계기가 됐어요. 추가로 애매했던 개념들도 다시 찾아보면서 웹 관련한 원론을 더 공부해야겠다는 생각이 들었어요.

기술에 대해 잘 아는것도 좋겠지만, 기본적인 개념도 중요하고 계속 공부해야겠다고 생각했어요.

## 출처

https://developer.mozilla.org/ko/docs/Web/Performance/Guides/How_browsers_work  
https://web.dev/articles/critical-rendering-path/constructing-the-object-model?hl=ko  
https://web.dev/articles/critical-rendering-path/render-tree-construction?hl=ko
