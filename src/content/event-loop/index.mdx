---
title: "이벤트 루프 제대로 알기"
titleStyle:
  - text: "이벤트 루프"
    isBold: true
  - text: " 제대로 알기"
    isBold: false
description: "자바스크립트의 이벤트 루프 동작방식에 대해 다시 알아봤어요"
category: "javascript"
tags: ["javascript"]
publishedAt: "2025년 8월 26일"
updatedAt: "2025년 8월 26일"
isPublished: true
---

## 여는 글

얼마 전 기술면접 중 겪은 경험을 통해 자바스크립트의 이벤트 루프에 대해 확실히 알고자 이 글을 써두려고 한다.

먼저 질문은 자바스크립트에서 동기 코드와, 비동기 코드가 어떻게 실행되는지에 대한 내용으로 나는 이렇게 답했다.

> **동기코드는 콜 스택을 통해 하나씩 담겨 순차적으로 실행되고 비동기 코드는 태스크 큐에 담기 대기하고 이벤트 루프가 콜 스택에 실행중인 함수가 있는지 확인하다가 비어있게 되면 태스크 큐에서 콜 스택으로 옮겨 비동기함수를 실행하게 됩니다.**

하지만 말하다 보니 스택이면 LIFO 순서로 실행되어야 하는데 실제 코드에서는 그렇지 않기 때문에 말하면서도 혼동이 오기 시작했다.
또한 비동기 코드를 실행하게 되면 태스크 큐에 옮겨지고 콜 스택이 비어있게 되면 비동기 코드를 그때 콜 스택에 옮겨담아 실행하는 것으로 알고 있었는데 그 부분도 아니라고 지적해주셔서 보완이 필요하다는 생각이 들었다.

그래서 내가 모호하게 알고 있던 개념들을 보완해보고자 한다.

## 콜 스택

다음 코드로 예시를 들어보겠다.

```tsx
function foo() {
  console.log("foo 실행");
}

function bar() {
  console.log("bar 시작");
  foo();
  console.log("bar 끝");
}

bar();
```

내가 말한 방식에 따르면 코드를 읽고 실행하면서 `bar`를 콜 스택에 담고 이후에 `foo`를 콜 스택에 담게되며 순서대로 꺼내 **실행**하게 되면

```
foo 실행
bar 시작
bar 끝
```

이렇게 되어야한다. 하지만 실제 실행 결과는

```
bar 시작
foo 실행
bar 끝
```

이렇게 된다고 명확하게 알고 있었다.

여기서부터 내가 정확히 이해하고 있는게 아니었구나라는 것을 알게 되었다.
면접과정에서 면접관님께서 설명해주신 내용과 내가 더 찾아본 내용을 통해 알게된 콜 스택은 **실행**하는 역할을 하지 않는다.

결론부터 말하자면 콜 스택은 실행 컨텍스트를 담아 함수 종료시 돌아갈 위치를 기억하는 자료구조이다.

위의 예시로 설명하면

1. `bar` 함수가 호출되면 `bar`함수의 실행 컨텍스트를 콜 스택에 push하고 `bar`함수를 실행해 내부 코드를 실행하게 된다.
2. `console.log("bar 시작")` 가 실행되고 `foo` 함수가 호출되어 `foo` 함수의 실행 컨텍스트를 콜 스택에 push한다.
3. `foo` 함수가 호출되면서 `console.log("foo 실행")`가 실행된다.
4. `foo` 함수가 종료되면 콜 스택에서 `foo` 함수가 제거되고 다음 스택인 `bar`로 돌아간다.
5. `bar` 함수 내부의 `foo`함수 호출 지점으로 돌아와 다음 코드인 `console.log("bar 끝")`을 실행하고 스택에서 `bar`를 제거하게 된다.

동기 코드는 이렇게 콜 스택에 실행 컨텍스트에 담아 돌아갈 위치를 기억하고 실행되게 된다. 다시 설명해보자면 다음과 같이 정리할 수 있다.

> 자바스크립트 엔진은 코드를 실행할 때 동기적으로 실행되는 함수가 호출되면 콜 스택에 해당 함수의 실행 컨텍스트를 push하고 종료되면 콜 스택에서 pop 해 이전 실행 지점으로 돌아가게 됩니다. 이러한 방식으로 동기 코드가 순차적으로 실행되게 됩니다.

## 이벤트 루프를 통한 비동기 코드 실행

내가 알고 있던 비동기 코드의 동작 방식은 호출된 뒤 태스크 큐(또는 마이크로태스크 큐)에 넘겨져 콜 스택에 있는 모든 작업이 종료되는 것을 이벤트 루프가 감지해서 큐에서 콜 스택으로 옮겨져 **실행**되는 것으로 알고 있었다.

하지만 이 개념도 마찬가지로 잘못된 것으로 실제로는 다음과 같이 동작한다.

1. 비동기 함수를 호출하면, 함수 자체는 동기적으로 실행된다.(호출 시 콜 스택에 push 후 바로 pop)
2. 내부의 콜백은 바로 실행되지 않고 Web API에 맡겨졌다가 조건이 충족 되면 큐에 등록되게 된다.
3. 콜 스택이 비어있게 되면 이벤트 루프가 확인해 큐에 있는 콜백 하나를 꺼내 호출하고 콜 스택에 push 한다.(이 과정은 동기 함수와 동일하게 동작한다.)

여기서 큐에 등록되는 과정은 비동기 함수의 종류에 따라 나뉘게 된다.

1. `setTimeout`, `setInterval`
   `setTimeout`, `setInterval`과 같은 Web API를 호출하면 자바스크립트 엔진이 처리하지 않고 해당 함수를 브라우저에 넘기게 된다.
   이후 브라우저는 지정된 타이머가 만료되면 내부 콜백을 매크로태스크 큐에 등록하게 된다.

2. `fetch`
   `fetch`, `axios` 등의 네트워크 요청 함수는 실행되자마자 Promise 객체를 반환(pending)하고 브라우저에 넘겨져 네트워크 요청을 시작한다.
   이후 실제 네트워크 응답이 도착하면 브라우저는 Promise를 resolve 또는 reject 상태로 변경하고 .then이나 .catch에 등록된 콜백을 마이크로태스크 큐에 등록하게 된다.

3. `eventListener`
   이벤트가 등록되는 시점에는 큐에 push 되지 않고 실제 이벤트가 발생했을 때 매크로태스크 큐에 handler 콜백이 등록되게 된다.

## 매크로태스크, 마이크로태스크

먼저 실행되는 각각의 태스크는 WHATWG HTML에서 정한 기준에 따라 매크로태스크와 마이크로태스크로 나뉜다.

- 매크로태스크 : 이벤트, 입력, 타이머, 네트워크 응답과 같은 외부와 연계된 작업. 비교적 큰 작업으로 간주되어 각 매크로태스크 사이에 브라우저가 렌더링 할 기회를 확보하기 위해 하나의 태스크씩 실행.
- 마이크로태스크 : `Promise` 체인과 같은 내부 로직의 후속 실행 작업, 비교적 작고 짧은 작업으로 렌더링 이전에 전부 처리하고 동기 작업이 끝난 후 이어서 실행해야하는 `Promise`/`async`/`await` 작업을 지원

```tsx
function foo() {
  console.log("A");

  setTimeout(() => console.log("timeout"), 0);
  setInterval(() => console.log("interval"), 1000);

  Promise.resolve().then(() => console.log("promise"));
}

foo();
```

이러한 코드를 실행할 때 각 태스크 큐의 관점에서 실행되는 순서는 다음과 같다.

1. 모든 스크립트 전체를 한 개의 작업으로 간주해 매크로태스크 큐에 넣어 실행한다. (console.log("A") 실행)
2. 이 과정에서 `Promise`, `setTimeout`, `setInterval`과 같은 비동기 코드 내부의 콜백은 각자 흐름에 맞게 Web API로 위임되어 조건 충족시에 큐에 등록된다.
3. 매크로태스크 큐에서 하나의 작업을 실행한 뒤 마이크로태스크 큐의 작업을 전부 실행한다.(console.log("promise") 실행, 만약 실행 중 새로운 마이크로태스크가 등록되면 큐가 빌때까지 계속 실행)
4. 이벤트 루프 사이클 종료 후 필요한 경우 렌더링 (렌더링 타이밍)
5. 매크로태스크 큐에서 하나의 작업을 실행한다.(`setTimeout`의 콜백 console.log("timeout") 실행)
6. 마이크로태스크 큐의 작업 전부 실행한다.(현재 작업 없음)
7. 렌더링 타이밍
8. 매크로태스크 큐를 확인하고 작업이 있는경우 하나의 작업을 실행한다.(`setInterval`의 콜백 console.log("interval") 실행, setInterval은 지정한 주기가 지날 때마다 매크로태스크 큐에 콜백을 계속 등록한다.)
9. 마이크로태스크 큐의 작업 전부 실행한다.
10. 반복

따라서 실제 실행 결과는 다음과 같다.

```
A
promise
timeout
interval
```

나는 마이크로태스크가 먼저 실행되고 매크로태스크가 실행되는것으로 알고 있었는데 처음 실행시 스크립트 전체가 매크로태스크로 간주되어 실행된 후 마이크로태스크가 실행되기 때문에 **마이크로태스크가 먼저 실행되는 것처럼 보인다**는 것을 알 수 있었다.

## 이벤트 루프

위에서 알아본 이벤트 루프의 규칙은 다음과 같다.

1. 매크로태스크 1개 실행
2. 마이크로태스크 전부 실행
3. 렌더링
4. 반복

이벤트 루프는 큐에 등록된 콜백이 있으면 콜 스택이 비는 순간을 감시해 큐에서 콜백을 가져와 자바스크립트 엔진에게 넘겨주는 역할을 한다.
(이후 자바스크립트 엔진은 콜백을 호출해 실행 컨텍스트를 콜 스택에 push 해 실행 위치를 기억하게한다.)

## 정리

자바스크립트에서 동기, 비동기 함수는 어떻게 실행되나요?

> 자바스크립트는 싱글 스레드 언어지만 비동기 함수를 브라우저의 Web API에 위임함으로써 병렬적으로 작업하는 이점을 가질 수 있습니다. 이러한 작업은 이벤트 루프에 의해 순차적으로 이루어지고 매크로태스크, 마이크로태스크, 렌더링의 순서를 가지며 하나의 루프를 갖게 됩니다. 자바스크립트 코드가 처음 실행되면 전체 코드를 매크로태스크로 간주해 실행하고, 코드를 진행하면서 동기 함수는 순차적으로 호출되어 호출 시 마다 콜 스택에 함수 종료 후 돌아갈 위치를 기록합니다.
>
> 비동기 함수를 만나게 되면 동기함수와 마찬가지로 호출되어 콜 스택에 push 되지만 자바스크립트 엔진은 이 비동기 코드를 Web API에 위임하고 콜 스택에서 바로 pop되어 다음 코드를 실행하게 됩니다. Web API에 위임된 비동기 코드 중 setTimeout과 같은 작업은 타이머 만료 후 매크로태스크 큐에 콜백이 등록되고 Promise와 같은 작업은 resolve 또는 reject 되는 순간에 then, catch 콜백을 마이크로태스크 큐에 등록합니다. 이렇게 각 매크로태스크가 종료될 때마다 대기중인 마이크로태스크를 전부 실행합니다. Promise를 통해 대기중인 then/catch 콜백을 실행하고 실행 컨텍스트를 만들어 콜 스택에 저장합니다. 모든 마이크로태스크를 종료했으면 필요시 렌더링 한 후 하나의 루프가 종료되게 됩니다.
>
> 이러한 순서를 가지는 이유는 큰 작업인 매크로태스크는 하나의 작업을 수행한 뒤 렌더링 할 수 있는 기회를 제공하고 Promise, async, await과 같은 마이크로태스크의 경우 후속작업을 렌더링 이전에 진행하게 할 수 있습니다. 이렇게 동기, 비동기 함수는 별도의 프로세스를 가지지만 이벤트 루프를 통해 하나의 싱글 스레드에서 최적화 된 작업을 진행할 수 있게 됩니다.
