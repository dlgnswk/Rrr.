---
title: "웹 브라우저의 가비지 콜렉터"
titleStyle:
  - text: "웹 브라우저의 "
    isBold: false
  - text: "가비지 콜렉터"
    isBold: true
description: "웹 브라우저에서 가비지 콜렉터가 동작하는 과정에 대해 알아봤어요."
category: "frontend"
tags: ["javascript"]
publishedAt: "2025년 4월 6일"
updatedAt: "2025년 4월 6일"
isPublished: true
---

## 여는 글

프론트엔드에서의 데이터 캐싱은 웹 페이지의 성능에 중요한 요소 중 하나로, 불필요한 요청과 로딩을 줄여줄 수 있어요.

그리고 캐싱과 밀접하게 연결된 개념인 가비지 콜렉터는 더 이상 사용되지 않는 데이터를 판단해 메모리에서 제거해 최적화해주는 역할을 해요.

그렇다면 이 가비지 콜렉터는 웹 브라우저에서 어떻게 동작하게 되는 것일까요?  
이 과정을 이해하면서 메모리를 최적화 하는 방법을 알아볼게요.

## JavaScript의 메모리

가비지 콜렉터의 동작 방식을 알아보기 전에 `JavaScript`가 데이터를 메모리에 어떻게 저장하는지 알아야 해요.

> [!Note] Why JavaScript?
> 웹에서 런타임 메모리를 직접 조작하는건 `JavaScript` 뿐이에요.
> 웹 브라우저의 가비지 콜렉터는 `JavaScript`가 생성한 데이터가 여전히 사용 중인지를 판단해 메모리를 관리하기 때문에, `JavaScript`가 어떻게 메모리에 데이터를 저장하는지 알아두는 것은 중요해요.

`JavaScript`에서는 모든 데이터, 값을 객체 그래프로 저장해요.

객체 그래프는 `window object`와 같이 `roots`부터 시작하는데, 가비지 콜렉터의 `roots`는 브라우저에 의해 생성되고 관리되기 때문에 사용자가 제어할 수 없어요.

<MDXImage
  src="posts/garbage-collector/js-graph.png"
  alt="root부터 그래프 형태로 저장되는 데이터"
  caption="root부터 그래프 형태로 저장되는 데이터"
/>

그럼 객체 그래프로 저장된 데이터는 언제 가비지 콜렉터의 제거 대상이 될까요?

정답은 **루트에서 해당 값으로 갈 수 있는 경로가 없을 때** 예요.

<MDXImage
  src="posts/garbage-collector/js-graph-garbage.png"
  alt="객체 그래프 내 도달할 수 있는 경로가 없는 값"
  caption="객체 그래프 내 도달할 수 있는 경로가 없는 값"
/>

이 그래프가 DOM 트리라고 해볼게요.

루트에서 도달할 수 없는 두개의 노드가 있고, 하나의 노드가 나머지 하나를 참조하고 있는 상황이에요.  
이럴 때 실제로 사용되지 않는 데이터가 메모리에 적재되어 있는 **메모리 누수**가 발생하게 돼요.

또, 불필요한 캐시를 과도하게 저장하고 있거나 사용하지 않는 이벤트 리스너, 동적으로 생성된 DOM 요소 등이 쌓이게 되면 더 많은 메모리를 소모하게 되고 이는 웹 성능의 저하로 이어지게 돼요.

이렇게 낭비되는 메모리를 회수하기 위해 브라우저는 도달되지 않고, 사용되지 않는 데이터를 가비지로 판단해 수집하는 가비지 콜렉션을 수행하게 돼요.

## 가비지 콜렉션 실행 순서

자세한 가비지 콜렉션 방식을 알아보기전에 크롬 V8 엔진의 가비지 콜렉션 실행 순서를 알아볼게요.

먼저 메모리를 새로운 객체가 저장되는 New Generation, 여러 번 생존한 객체가 저장되는 Old Generation 두 세대로 나누어요.

새로 생성된 객체들은 New Generation의 `from` 공간에 저장하고 이 공간이 가득 차면 가비지 콜렉션(Scavenge)이 실행돼요.

살아남은 객체는 `to` 공간으로 복사되고, 이후 `from`과 `to`의 역할을 바꿔요. 이 과정을 반복하면서 오래 살아남은 객체는 Old Generation으로 승격돼요.

이런 과정을 통해 오래된 객체는 Old Generation으로 옮겨지고, 이 영역에서는 별도의 방식으로 가비지 콜렉션이 수행돼요.

## 가비지 콜렉션(Scavenge)의 두가지 방식

가비지 콜렉터는 사용되지 않는 값을 가비지로 판단하기 위해 두 가지 알고리즘을 사용해요:

### Mark and Sweep / Compact Algorithm

<p> </p>

<MDXImage
  src="posts/garbage-collector/mark-and-sweep.gif"
  width="300px"
  alt="mark, sweep 단계"
  caption="mark, sweep 단계"
/>

루트부터 접근 가능한 모든 객체를 사용 중으로 표시하는 `Mark` 단계를 진행해 도달할 수 있는 모든 객체를 표시해요.

이후 모든 메모리를 스캔하여 사용중으로 표시되지 않은 객체의 메모리를 해제하고 모든 사용 중으로 표시했던 마킹 정보를 제거하는 `Sweep` 단계를 진행해요.

<MDXImage
  src="posts/garbage-collector/compact.png"
  width="300px"
  alt="sweep 후 단편화 된 메모리"
  caption="sweep 후 단편화 된 메모리"
/>

`Sweep` 단계를 거치면 사용되지 않은 객체가 메모리가 해제되어 중간 중간 비어있는 메모리 단편화가 일어나게 되요.

상황에 따라 단편화를 줄이기 위해 살아남은 객체를 한쪽으로 정리하는 `Compact` 단계를 수행하기도 해요.

### Tri color Marking Algorithm

`Mark` 단계에서 도달 가능한 객체를 표시하기 위해서 `Tri Color` 라는 알고리즘을 사용해요.

말 그대로 흰색, 회색, 검정색의 세가지 색으로 구분해 마킹하게 되는데 각 색의 표시 정보는 다음과 같아요:

- 흰색: 아직 검사하지 않은 객체
- 회색: 검사는 했지만 모든 참조를 확인하지 않은 객체
- 검정색: 완전히 검사한 객체

<MDXImage
  src="posts/garbage-collector/tri-color.gif"
  width="300px"
  alt="tri color 알고리즘"
  caption="tri color 알고리즘"
/>

모든 객체의 초기 상태는 흰색 상태로 간주하고, 루트에서 도달 가능한 직접 참조되는 모든 객체를 회색 큐에 등록해요.

회색 큐에 등록된 객체는 자식 객체들을 회색 큐에 등록한 뒤 자신은 검정색으로 마킹해요.

이 과정을 반복해 회색 큐에 비어있게 되면 `Mark` 단계를 종료하고 이후 `Sweep` 단계에서 흰색으로 남아있는 객체를 가비지로 간주해 메모리를 제거해요.

## 메모리 해제 이후

`Sweep` 단계를 통해 사용되지 않는 메모리 블록이 식별되면, 이 블록을 `Free List`에 등록해요.

`Free List`는 `Linked List` 형태로 구성된 할당 가능한 빈 메모리 블록의 목록으로 새로운 객체를 저장 할 때, 이 `Free List`에서 적절한 크기의 블록을 찾아서 재사용하게 돼요.

메모리를 해제하고 난 뒤, 해제한 블록과 인접한 빈 블록이 존재하면 두 블록을 병합하고 더 큰 메모리 블록으로 만듦으로 메모리 단편화를 줄일 수 있어요.

## 닫는 글

많은 데이터를 사용하지 않는 프로젝트라면 코드를 작성하면서 메모리를 고려하지 않고 작업하는 경우도 많아요.

그동안 코드를 작성하면서 이벤트 핸들러, 캐시, DOM 요소 등을 동적으로 추가하고 제대로 해제하지 않으면서 메모리 누수를 방치했던 것 같아요.

이번에 웹 브라우저의 가비지 콜렉터가 어떻게 동작하는지를 살펴보면서, 메모리에 대해 더 잘 이해할 수 있게 되었어요.

앞으로는 메모리 관리를 고려한 코드를 작성할 수 있도록 노력하려고 해요.

## 출처

https://web.dev/articles/effectivemanagement?hl=ko  
https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na%C3%AFve_mark-and-sweep  
https://siahn95.tistory.com/108
